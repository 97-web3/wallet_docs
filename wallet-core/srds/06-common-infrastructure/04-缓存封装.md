# 缓存封装 (cache/)

## F-CACHE-001: Redis 缓存封装

- **描述**: 基于 go-redis/v9 的全功能缓存封装
- **文件**: `common/cache/redis_cache.go`
- **功能**:
  - 键前缀管理
  - 字符串操作 (Set/Get/Delete/Exists)
  - JSON 序列化存储
  - 原子计数 (Incr/Decr)
  - Hash 操作
  - List 操作
  - Set 操作
  - Sorted Set 操作
  - 分布式锁

---

## 分布式锁

```go
// 获取锁
unlock, err := cache.Lock(ctx, "resource_key", time.Second*30)
if err != nil {
    // 获取锁失败
}
defer unlock()  // 释放锁

// 带重试的锁
unlock, err := cache.LockWithRetry(ctx, "resource_key", time.Second*30, 3, time.Millisecond*100)
```

---

## 支持的操作

| 类别 | 方法 |
|------|------|
| 字符串 | Set, Get, SetJSON, GetJSON, Delete, Exists, Expire, TTL |
| 计数 | Incr, IncrBy, Decr, DecrBy |
| Hash | HSet, HGet, HGetAll, HDel, HExists |
| List | LPush, RPush, LPop, RPop, LRange, LLen |
| Set | SAdd, SRem, SMembers, SIsMember, SCard |
| Sorted Set | ZAdd, ZRem, ZRange, ZRevRange, ZRangeByScore, ZCard, ZScore |
| 分布式锁 | Lock, LockWithRetry, SetNX |

---

## F-CACHE-002: 价格缓存策略

**描述**: 代币价格数据的缓存策略，平衡数据实时性和系统稳定性。

### 缓存配置

| 配置项 | 值 | 说明 |
|--------|-----|------|
| 主数据源 | Debank API | 主要价格源 |
| 备用数据源 | CoinGecko API | 主数据源不可用时降级 |
| 缓存 TTL | 30 秒 | 正常缓存时间 |
| 过期容忍 TTL | 5 分钟 | 刷新失败时继续使用 |
| Redis Key 格式 | `price:{asset}:{currency}` | 缓存键格式 |

### 缓存结构

```json
{
  "price": "0.1012",
  "source": "debank",
  "updated_at": "2025-12-10T10:00:00Z",
  "stale": false
}
```

### 读取逻辑

```go
func GetPrice(ctx context.Context, asset, currency string) (*PriceData, error) {
    key := fmt.Sprintf("price:%s:%s", asset, currency)

    // 1. 尝试从缓存读取
    data, err := cache.GetJSON(ctx, key, &PriceData{})
    if err == nil && data != nil {
        return data, nil
    }

    // 2. 缓存未命中，调用外部 API
    price, err := fetchFromDebank(asset, currency)
    if err != nil {
        // 3. API 失败，尝试使用过期数据
        staleData, _ := cache.GetJSON(ctx, key+"_stale", &PriceData{})
        if staleData != nil {
            staleData.Stale = true
            return staleData, nil
        }
        return nil, err
    }

    // 4. 更新缓存
    cache.SetJSON(ctx, key, price, time.Second*30)
    cache.SetJSON(ctx, key+"_stale", price, time.Minute*5)  // 备用过期缓存

    return price, nil
}
```

### 刷新策略

- **正常情况**: 缓存 30 秒，到期后重新获取
- **API 超时**: 使用过期缓存 (最多 5 分钟前)，标记 `stale=true`
- **API 错误**: 同上，同时告警通知
- **缓存穿透保护**: 对不存在的资产缓存空值 60 秒

---

> 返回 [Common Infrastructure 目录](./README.md)
